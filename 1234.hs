   --
   -----------
   import List

   abc = [100..999]
   -- "Выпиливание" цифр...
   --------------------------------
   t1 = map (\x -> x `div` 100) abc
   t2 = map (\x -> mod (x `div` 10) 10) abc
   t3 = map (\x -> x `mod` 10) abc

   t4 = concatMap id 
                  $ map (\x -> show $ maximum x - minimum x) 
                  $     zipWith3 (\a b c -> [a,b,c]) t1 t2 t3
   res = (sortALKey'. prob)

   -- ***********************************************
   -- Функция возвращает результат частотного анализа
   -- букв текста word в виде списка пар вида:
   --
   -- (Частота появления символа в слове, 
   --  Строка, состоящая из этого символа)
   ---------------------------------------
   prob word = sort [(x:"",
                      fromInt (length (findIndices (==x) word)) 
                              / (fromInt (length word)))
                    | x <- nub word]

   -- ****************************************************
   -- Функция возвращает энтропию дискретного источника по
   -- известному ансамблю lst, представляющем собой список
   -- пар (в битах)
   -----------------------------
   entr2 lst = -sum (zipWith (*)
                             lst1       
                             (map (\x -> logBase 2.0 x) lst1))
        where lst1 = map (\x -> snd x) lst

   -- **********************************************
   -- Функция, сортирующая содержимое ассоциативного
   -- списка aList
   --   (а) по возрастанию ключей;
   --   (б) по убыванию ключей
   -------------------------------------------------
   sortALKey':: (Ord a, Ord b) => [(a,b)] -> [(a,b)]
   sortALKey' aList 
        = sortBy (\x y -> on compare snd y x) aList

   -- *****************************************************
   -- Вспомогательная функция, моделирующая комбинатор psi. 
   -- Его аналогом в GHCi является функция on:
   --
   --  > :m Data.Function
   --  > :t on
   --  (b -> b -> c) -> (a -> b) -> (a -> a -> c)
   ----------------------------------------------
   on g f x y = g (f x) (f y)
