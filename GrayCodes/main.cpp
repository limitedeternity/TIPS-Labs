#include <iostream>
#include <bitset>

/*
 * Демонстрация перевода чисел из двоичной системы счисления в код Грея
 * и обратно.
 *
 * Автор: Беспалов В. (3 курс, ИС, 17.09.2020)
 */

#define MAX_INT 2147483648
using namespace std;

/*
 * Свойства <отражённого> кода Грея:
 * 1) Каждая комбинация битов появляется в списке единожды
 * 2) Рядом стоящие комбинации битов (с индексами i, i+1 и i, i-1) отличаются ровно на один бит
 * 3) Только один бит изменяется при переходе от последней комбинации битов к первой
*/

// ==========================

/*
 * Вычисление кода Грея для выбранного числа:
 * Пусть переменная bin подходит под шаблон abcd, где a, b, c, d – либо 0, либо 1.
 * Тогда представление переменной bin в виде кода Грея подходит под шаблон efgh, где
 * e, f, g, h – либо 0, либо 1.
 * 
 * Между abcd и efgh существуют следующие отношения:
 * e = a
 * f = a ⊕ b
 * g = b ⊕ c
 * h = c ⊕ d
 *
 * Экстраполируя, получим алгоритм для нахождения кода Грея для любого двоичного числа, 
 * описанный в книге Генри Уоррена мл. "Алгоритмические трюки для программистов":
*/

unsigned binToGrey(unsigned bin) {
    return bin ^ (bin >> 1);
}

/*
 * Проведём трассировку (в двоичной СС):
 * bin = 1010
 * (1010 >> 1) = 0101
 * 1010 ^ 0101 = 1111
 * ------------------
 * e = a ^ 0 = 1 ^ 0 = 1
 * f = b ^ a = 0 ^ 1 = 1
 * g = c ^ b = 1 ^ 0 = 1
 * h = d ^ c = 0 ^ 1 = 1
 * ------------------
*/

// ==================================

/*
 * Восстановление исходного числа по коду Грея:
 * Пусть переменная grey подходит под шаблон efgh, где e, f, g, h – либо 0, либо 1.
 * Тогда восстановленное число по коду Грея (переменной grey) подходит под шаблон abcd, где
 * a, b, c, d – либо 0, либо 1.
 *
 * Между efgh и abcd существуют следующие отношения:
 * a = e
 * b = e ⊕ f
 * c = e ⊕ f ⊕ g
 * d = e ⊕ f ⊕ g ⊕ h
 *
 * Экстраполируя, получим алгоритм для восстановления исходного числа по коду Грея
 * на основе описанного в книге Генри Уоррена мл. "Алгоритмические трюки для программистов":
*/

// Функция, вычисляющая <целочисленный> логарифм по основанию 2.
unsigned log2(unsigned x) {
    unsigned z = x;
    unsigned result = 0;
    while (z >>= 1) result++;
    return result;
}

unsigned greyToBin(unsigned grey) {
    unsigned bin = grey;
    // Количество занимаемых числом битов
    unsigned bits = log2(grey) + 1;
    for (unsigned i = 0; (1 << i) < bits; i++) {
        bin ^= bin >> (1 << i);
    }
    return bin;
}

/*
 * Проведём трассировку (в двоичной СС):
 * grey = 1111
 * bits = 4
 * 1111 >> (1 << 0) = 0111
 * 1111 ^ 0111 = 1000
 * 1000 >> (1 << 1) = 0010
 * 1000 ^ 0010 = 1010
 * ------------------
 * a = e ^ 0 = 1 ^ 0 = 1
 * b = e ^ f = 1 ^ 1 = 0
 * c = e ^ f ^ g = 1 ^ 1 ^ 1 = 1
 * d = e ^ f ^ g ^ h = 1 ^ 1 ^ 1 ^ 1 = 0
 * ------------------
*/

// ==================================

int main(void) {
    for (unsigned i = MAX_INT - 20; i < MAX_INT - 1; i++) {
        string bin = bitset<32>(i).to_string();
        bin.erase(0, bin.find_first_not_of('0'));

        string grey = bitset<32>(binToGrey(i)).to_string();
        grey.erase(0, grey.find_first_not_of('0'));

        string backFromGrey = bitset<32>(greyToBin(binToGrey(i))).to_string();
        backFromGrey.erase(0, backFromGrey.find_first_not_of('0'));

        cout << "Binary: " << bin << " -> " << endl;
        cout << "Grey: " << grey << " -> " << endl;
        cout << "Back: " << backFromGrey << endl;
        cout << endl;
    }
    return 0;
}
